package info.getbus.servebus.route.persistence.managers;import info.getbus.servebus.route.model.Direction;import info.getbus.servebus.route.model.Route;import info.getbus.servebus.route.model.RouteStop;import info.getbus.servebus.route.persistence.LockedRouteException;import info.getbus.servebus.route.persistence.RouteAwareBaseTest;import info.getbus.servebus.route.persistence.mappers.RouteMapper;import info.getbus.servebus.route.persistence.mappers.RouteStopMapper;import org.junit.Test;import org.junit.runner.RunWith;import org.mockito.InOrder;import org.mockito.InjectMocks;import org.mockito.Mock;import org.mockito.Spy;import org.mockito.junit.MockitoJUnitRunner;import static org.junit.jupiter.api.Assertions.assertThrows;import static org.mockito.ArgumentMatchers.any;import static org.mockito.ArgumentMatchers.eq;import static org.mockito.Mockito.doAnswer;import static org.mockito.Mockito.inOrder;import static org.mockito.Mockito.times;import static org.mockito.Mockito.verify;import static org.mockito.Mockito.verifyNoMoreInteractions;import static org.mockito.Mockito.when;@RunWith(MockitoJUnitRunner.class)public class RoutePersistenceManagerImplTest extends RouteAwareBaseTest {    @Mock    private    RouteMapper routeMapper;    @Mock    private    RouteStopMapper stopMapper;    @InjectMocks    @Spy    private    RoutePersistenceManagerImpl pm;    @Test    public void saveStopsF() throws Exception {        route.setDirection(Direction.F);        route.setId(2L);        pm.saveStops(route);        InOrder inOrder = inOrder(stopMapper);        inOrder.verify(stopMapper).negateSequence(eq(route.getId()));        for (RouteStop stop : route.getRoutePointsInNaturalOrder()) {            inOrder.verify(stopMapper).upsert(eq(stop));            inOrder.verify(stopMapper).upsertLength(eq(stop), eq(route.getDirection()));            inOrder.verify(stopMapper).upsertTimetable(eq(stop), eq(route.getDirection()));        }        inOrder.verify(stopMapper).deleteOutOfRange(eq(route.getId()), eq(route.getStops().size()));        inOrder.verifyNoMoreInteractions();    }    @Test    public void saveStopsR() throws Exception {        route.setDirection(Direction.R);        route.setId(2L);        pm.saveStops(route);        InOrder inOrder = inOrder(stopMapper);        for (RouteStop stop : route.getRoutePointsInNaturalOrder()) {            inOrder.verify(stopMapper).upsertLength(eq(stop), eq(route.getDirection()));            inOrder.verify(stopMapper).upsertTimetable(eq(stop), eq(route.getDirection()));        }        inOrder.verifyNoMoreInteractions();    }    @Test    public void createRoute() throws Exception {        setUpRouteInsert(routeMapper);        long transporterAreaId = 44;        user.setTransporterAreaId(transporterAreaId);        pm.createRoute(route, user, true);        InOrder inOrder = inOrder(routeMapper, pm);        inOrder.verify(routeMapper).insertLocked(eq(transporterAreaId), eq(route), eq(user.getUsername()));        verifyNoMoreInteractions(routeMapper);        inOrder.verify(pm, times(1)).saveStops(eq(route));    }    private void setUpRouteInsert(RouteMapper routeMapper) {        doAnswer( invocation -> {            ((Route)invocation.getArguments()[1]).setId(1L);            return null;        }).when(routeMapper).insertLocked(any(), any(), any());    }    @Test    public void tryToLockFor() throws Exception {        when(routeMapper.selectLockOwnerForUpdate(1L)).thenReturn("11");        pm.tryLockFor(1L, "11");        verify(routeMapper).selectLockOwnerForUpdate(eq(1L));        verifyNoMoreInteractions(routeMapper);    }    @Test    public void tryToLockFor_null() throws Exception {        when(routeMapper.selectLockOwnerForUpdate(1L)).thenReturn(null);        pm.tryLockFor(1L, "11");        InOrder inOrder = inOrder(routeMapper);        inOrder.verify(routeMapper).selectLockOwnerForUpdate(eq(1L));        inOrder.verify(routeMapper).updateLockOwner(eq(1L), eq("11"));        verifyNoMoreInteractions(routeMapper);    }    @Test    public void tryToLockFor_oth() throws Exception {        when(routeMapper.selectLockOwnerForUpdate(1L)).thenReturn("22");        assertThrows(LockedRouteException.class, () -> pm.tryLockFor(1L, "11"));        verify(routeMapper).selectLockOwnerForUpdate(eq(1L));        verifyNoMoreInteractions(routeMapper);    }    @Test    public void checkLock() throws Exception {        when(routeMapper.selectLockOwner(1L)).thenReturn("11");        pm.checkLock(1L, "11");        verify(routeMapper).selectLockOwner(1L);        verifyNoMoreInteractions(routeMapper);    }    @Test    public void checkLock_null() throws Exception {        when(routeMapper.selectLockOwner(1L)).thenReturn(null);        assertThrows(LockedRouteException.class, () -> pm.checkLock(1L, "11"));        verify(routeMapper).selectLockOwner(eq(1L));        verifyNoMoreInteractions(routeMapper);    }    @Test    public void checkLock_other() throws Exception {        when(routeMapper.selectLockOwner(1L)).thenReturn("22");        assertThrows(LockedRouteException.class, () -> pm.checkLock(1L, "11"));        verify(routeMapper).selectLockOwner(eq(1L));        verifyNoMoreInteractions(routeMapper);    }}